// Copyright (c) Robin Mordasiewicz
// SPDX-License-Identifier: MPL-2.0

// Package main provides the OpenAPI-to-Terraform code generator.
// This tool parses F5 XC OpenAPI specifications and generates Terraform
// provider resources and data sources automatically.
//
// Usage:
//
//	go run tools/generator/main.go
//
// The generator will:
// 1. Parse all OpenAPI specs in docs/specifications/api/
// 2. Generate resource code in internal/resources/
// 3. Generate data source code in internal/datasources/
// 4. Update internal/provider/provider.go with imports and registrations
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"
)

// OpenAPISpec represents the relevant parts of an OpenAPI specification
type OpenAPISpec struct {
	Info  OpenAPIInfo         `json:"info"`
	Paths map[string]PathItem `json:"paths"`
	Tags  []Tag               `json:"tags"`
}

type OpenAPIInfo struct {
	Title       string `json:"title"`
	Description string `json:"description"`
	Version     string `json:"version"`
}

type PathItem struct {
	Get    *Operation `json:"get"`
	Post   *Operation `json:"post"`
	Put    *Operation `json:"put"`
	Delete *Operation `json:"delete"`
}

type Operation struct {
	OperationID string   `json:"operationId"`
	Summary     string   `json:"summary"`
	Description string   `json:"description"`
	Tags        []string `json:"tags"`
}

type Tag struct {
	Name        string `json:"name"`
	Description string `json:"description"`
}

// ResourceInfo contains extracted information about a resource
type ResourceInfo struct {
	Name        string // snake_case name for Terraform
	PackageName string // Go package name
	StructName  string // PascalCase struct name
	TypeName    string // Terraform type name (f5distributedcloud_*)
	APIPath     string // Base API path
	HasCreate   bool   // POST operation exists
	HasRead     bool   // GET operation exists
	HasUpdate   bool   // PUT operation exists
	HasDelete   bool   // DELETE operation exists
	HasList     bool   // List GET operation exists
	Description string // Resource description
	SpecFile    string // Source OpenAPI spec file
}

// Template for generating a resource file
const resourceTemplate = `// Copyright (c) Robin Mordasiewicz
// SPDX-License-Identifier: MPL-2.0

// Code generated by tools/generator. DO NOT EDIT.

package {{.PackageName}}

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/robinmordasiewicz/terraform-provider-f5distributedcloud/internal/client"
)

var _ resource.Resource = &{{.StructName}}Resource{}
var _ resource.ResourceWithImportState = &{{.StructName}}Resource{}

func New{{.StructName}}Resource() resource.Resource {
	return &{{.StructName}}Resource{}
}

type {{.StructName}}Resource struct {
	client *client.Client
}

type {{.StructName}}ResourceModel struct {
	ID          types.String ` + "`tfsdk:\"id\"`" + `
	Name        types.String ` + "`tfsdk:\"name\"`" + `
	Namespace   types.String ` + "`tfsdk:\"namespace\"`" + `
	Description types.String ` + "`tfsdk:\"description\"`" + `
	Labels      types.Map    ` + "`tfsdk:\"labels\"`" + `
	Annotations types.Map    ` + "`tfsdk:\"annotations\"`" + `
}

type API{{.StructName}} struct {
	Metadata struct {
		Name        string            ` + "`json:\"name\"`" + `
		Namespace   string            ` + "`json:\"namespace,omitempty\"`" + `
		Description string            ` + "`json:\"description,omitempty\"`" + `
		UID         string            ` + "`json:\"uid,omitempty\"`" + `
		Labels      map[string]string ` + "`json:\"labels,omitempty\"`" + `
		Annotations map[string]string ` + "`json:\"annotations,omitempty\"`" + `
	} ` + "`json:\"metadata\"`" + `
	Spec map[string]interface{} ` + "`json:\"spec,omitempty\"`" + `
}

func (r *{{.StructName}}Resource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_{{.Name}}"
}

func (r *{{.StructName}}Resource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "{{.Description}}",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Description: "Unique identifier of the resource.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"name": schema.StringAttribute{
				Description: "Name of the resource.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"namespace": schema.StringAttribute{
				Description: "Namespace where the resource will be created.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"description": schema.StringAttribute{
				Description: "Description of the resource.",
				Optional:    true,
			},
			"labels": schema.MapAttribute{
				Description: "Labels for the resource.",
				Optional:    true,
				ElementType: types.StringType,
			},
			"annotations": schema.MapAttribute{
				Description: "Annotations for the resource.",
				Optional:    true,
				ElementType: types.StringType,
			},
		},
	}
}

func (r *{{.StructName}}Resource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	c, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError("Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T", req.ProviderData))
		return
	}
	r.client = c
}

func (r *{{.StructName}}Resource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data {{.StructName}}ResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	apiReq := API{{.StructName}}{}
	apiReq.Metadata.Name = data.Name.ValueString()
	apiReq.Metadata.Namespace = data.Namespace.ValueString()
	if !data.Description.IsNull() {
		apiReq.Metadata.Description = data.Description.ValueString()
	}

	var apiResp API{{.StructName}}
	path := fmt.Sprintf("{{.APIPath}}/%s/{{.APIResource}}", data.Namespace.ValueString())
	if err := r.client.Post(ctx, path, apiReq, &apiResp); err != nil {
		resp.Diagnostics.AddError("Error Creating {{.StructName}}",
			fmt.Sprintf("Could not create {{.Name}} %s/%s: %s", data.Namespace.ValueString(), data.Name.ValueString(), err))
		return
	}

	data.ID = types.StringValue(apiResp.Metadata.UID)
	if data.ID.ValueString() == "" {
		data.ID = types.StringValue(apiResp.Metadata.Namespace + "/" + apiResp.Metadata.Name)
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *{{.StructName}}Resource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data {{.StructName}}ResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var apiResp API{{.StructName}}
	path := fmt.Sprintf("{{.APIPath}}/%s/{{.APIResource}}/%s", data.Namespace.ValueString(), data.Name.ValueString())
	if err := r.client.Get(ctx, path, &apiResp); err != nil {
		resp.Diagnostics.AddError("Error Reading {{.StructName}}",
			fmt.Sprintf("Could not read {{.Name}} %s/%s: %s", data.Namespace.ValueString(), data.Name.ValueString(), err))
		return
	}

	data.Name = types.StringValue(apiResp.Metadata.Name)
	data.Namespace = types.StringValue(apiResp.Metadata.Namespace)
	if apiResp.Metadata.Description != "" {
		data.Description = types.StringValue(apiResp.Metadata.Description)
	}
	if apiResp.Metadata.UID != "" {
		data.ID = types.StringValue(apiResp.Metadata.UID)
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *{{.StructName}}Resource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data {{.StructName}}ResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	apiReq := API{{.StructName}}{}
	apiReq.Metadata.Name = data.Name.ValueString()
	apiReq.Metadata.Namespace = data.Namespace.ValueString()
	if !data.Description.IsNull() {
		apiReq.Metadata.Description = data.Description.ValueString()
	}

	var apiResp API{{.StructName}}
	path := fmt.Sprintf("{{.APIPath}}/%s/{{.APIResource}}/%s", data.Namespace.ValueString(), data.Name.ValueString())
	if err := r.client.Put(ctx, path, apiReq, &apiResp); err != nil {
		resp.Diagnostics.AddError("Error Updating {{.StructName}}",
			fmt.Sprintf("Could not update {{.Name}} %s/%s: %s", data.Namespace.ValueString(), data.Name.ValueString(), err))
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *{{.StructName}}Resource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data {{.StructName}}ResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	path := fmt.Sprintf("{{.APIPath}}/%s/{{.APIResource}}/%s", data.Namespace.ValueString(), data.Name.ValueString())
	if err := r.client.Delete(ctx, path); err != nil {
		resp.Diagnostics.AddError("Error Deleting {{.StructName}}",
			fmt.Sprintf("Could not delete {{.Name}} %s/%s: %s", data.Namespace.ValueString(), data.Name.ValueString(), err))
		return
	}
}

func (r *{{.StructName}}Resource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}
`

// Template for generating a data source file
const datasourceTemplate = `// Copyright (c) Robin Mordasiewicz
// SPDX-License-Identifier: MPL-2.0

// Code generated by tools/generator. DO NOT EDIT.

package {{.PackageName}}

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/robinmordasiewicz/terraform-provider-f5distributedcloud/internal/client"
)

var _ datasource.DataSource = &{{.StructName}}DataSource{}

func New{{.StructName}}DataSource() datasource.DataSource {
	return &{{.StructName}}DataSource{}
}

type {{.StructName}}DataSource struct {
	client *client.Client
}

type {{.StructName}}DataSourceModel struct {
	ID          types.String ` + "`tfsdk:\"id\"`" + `
	Name        types.String ` + "`tfsdk:\"name\"`" + `
	Namespace   types.String ` + "`tfsdk:\"namespace\"`" + `
	Description types.String ` + "`tfsdk:\"description\"`" + `
}

type API{{.StructName}}DS struct {
	Metadata struct {
		Name        string ` + "`json:\"name\"`" + `
		Namespace   string ` + "`json:\"namespace,omitempty\"`" + `
		Description string ` + "`json:\"description,omitempty\"`" + `
		UID         string ` + "`json:\"uid,omitempty\"`" + `
	} ` + "`json:\"metadata\"`" + `
}

func (d *{{.StructName}}DataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_{{.Name}}"
}

func (d *{{.StructName}}DataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Fetches information about an existing F5 Distributed Cloud {{.StructName}}.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Description: "Unique identifier of the {{.Name}}.",
				Computed:    true,
			},
			"name": schema.StringAttribute{
				Description: "Name of the {{.Name}} to look up.",
				Required:    true,
			},
			"namespace": schema.StringAttribute{
				Description: "Namespace where the {{.Name}} exists.",
				Required:    true,
			},
			"description": schema.StringAttribute{
				Description: "Description of the {{.Name}}.",
				Computed:    true,
			},
		},
	}
}

func (d *{{.StructName}}DataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	c, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError("Unexpected Data Source Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T", req.ProviderData))
		return
	}
	d.client = c
}

func (d *{{.StructName}}DataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data {{.StructName}}DataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var apiResp API{{.StructName}}DS
	path := fmt.Sprintf("{{.APIPath}}/%s/{{.APIResource}}/%s", data.Namespace.ValueString(), data.Name.ValueString())
	if err := d.client.Get(ctx, path, &apiResp); err != nil {
		resp.Diagnostics.AddError("Error Reading {{.StructName}}",
			fmt.Sprintf("Could not read {{.Name}} %s/%s: %s", data.Namespace.ValueString(), data.Name.ValueString(), err))
		return
	}

	data.Name = types.StringValue(apiResp.Metadata.Name)
	data.Namespace = types.StringValue(apiResp.Metadata.Namespace)
	if apiResp.Metadata.UID != "" {
		data.ID = types.StringValue(apiResp.Metadata.UID)
	} else {
		data.ID = types.StringValue(apiResp.Metadata.Namespace + "/" + apiResp.Metadata.Name)
	}
	if apiResp.Metadata.Description != "" {
		data.Description = types.StringValue(apiResp.Metadata.Description)
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
`

func main() {
	log.Println("F5 XC Terraform Provider Code Generator")
	log.Println("========================================")

	// Get project root
	projectRoot, err := findProjectRoot()
	if err != nil {
		log.Fatalf("Failed to find project root: %v", err)
	}
	log.Printf("Project root: %s", projectRoot)

	// Parse all OpenAPI specs
	specsDir := filepath.Join(projectRoot, "docs", "specifications", "api")
	resources, err := parseAllSpecs(specsDir)
	if err != nil {
		log.Fatalf("Failed to parse specs: %v", err)
	}
	log.Printf("Found %d resources from OpenAPI specs", len(resources))

	// Generate resource code
	resourcesDir := filepath.Join(projectRoot, "internal", "resources")
	datasourcesDir := filepath.Join(projectRoot, "internal", "datasources")

	generated := 0
	for _, res := range resources {
		// Generate resource if CRUD operations exist
		if res.HasCreate && res.HasRead && res.HasDelete {
			if err := generateResource(resourcesDir, res); err != nil {
				log.Printf("Warning: Failed to generate resource %s: %v", res.Name, err)
			} else {
				generated++
			}
		}

		// Generate data source if read operation exists
		if res.HasRead {
			if err := generateDataSource(datasourcesDir, res); err != nil {
				log.Printf("Warning: Failed to generate data source %s: %v", res.Name, err)
			}
		}
	}

	log.Printf("Generated %d resources", generated)

	// Generate provider.go imports
	if err := generateProviderImports(projectRoot, resources); err != nil {
		log.Fatalf("Failed to generate provider imports: %v", err)
	}

	// Generate documentation and examples
	if err := generateAllDocs(projectRoot, resources); err != nil {
		log.Fatalf("Failed to generate documentation: %v", err)
	}

	log.Println("Code generation complete!")
}

func findProjectRoot() (string, error) {
	// Start from current directory and look for go.mod
	dir, err := os.Getwd()
	if err != nil {
		return "", err
	}

	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			return "", fmt.Errorf("could not find project root (no go.mod found)")
		}
		dir = parent
	}
}

func parseAllSpecs(specsDir string) ([]ResourceInfo, error) {
	var resources []ResourceInfo

	files, err := os.ReadDir(specsDir)
	if err != nil {
		return nil, fmt.Errorf("failed to read specs directory: %w", err)
	}

	for _, file := range files {
		if !strings.HasSuffix(file.Name(), ".json") {
			continue
		}

		specPath := filepath.Join(specsDir, file.Name())
		res, err := parseSpec(specPath)
		if err != nil {
			log.Printf("Warning: Failed to parse %s: %v", file.Name(), err)
			continue
		}

		if res != nil {
			resources = append(resources, *res)
		}
	}

	// Sort by name for consistent output
	sort.Slice(resources, func(i, j int) bool {
		return resources[i].Name < resources[j].Name
	})

	return resources, nil
}

func parseSpec(specPath string) (*ResourceInfo, error) {
	data, err := os.ReadFile(specPath)
	if err != nil {
		return nil, err
	}

	var spec OpenAPISpec
	if err := json.Unmarshal(data, &spec); err != nil {
		return nil, err
	}

	// Extract resource name from filename
	// Format: docs-cloud-f5-com.XXXX.public.ves.io.schema.<resource>.ves-swagger.json
	filename := filepath.Base(specPath)
	resourceName := extractResourceName(filename)
	if resourceName == "" {
		return nil, nil // Skip files that don't match the pattern
	}

	// Analyze paths for CRUD operations
	res := &ResourceInfo{
		Name:        resourceName,
		PackageName: strings.ReplaceAll(resourceName, "-", "_"),
		StructName:  toStructName(resourceName),
		TypeName:    "f5distributedcloud_" + resourceName,
		SpecFile:    filename,
		Description: cleanDescription(spec.Info.Description),
	}

	// Analyze paths
	for path, item := range spec.Paths {
		// Detect CRUD operations based on path patterns
		if strings.Contains(path, "/create") || (item.Post != nil && !strings.Contains(path, "/list")) {
			res.HasCreate = true
		}
		if item.Get != nil {
			if strings.Contains(path, "/list") || strings.HasSuffix(path, "s") {
				res.HasList = true
			} else {
				res.HasRead = true
			}
		}
		if item.Put != nil || strings.Contains(path, "/replace") {
			res.HasUpdate = true
		}
		if item.Delete != nil {
			res.HasDelete = true
		}

		// Extract API path
		if res.APIPath == "" {
			res.APIPath = extractAPIPath(path)
		}
	}

	// Only return if it has meaningful operations
	if !res.HasCreate && !res.HasRead && !res.HasList {
		return nil, nil
	}

	return res, nil
}

func extractResourceName(filename string) string {
	// Pattern: docs-cloud-f5-com.XXXX.public.ves.io.schema.<rest>.ves-swagger.json
	re := regexp.MustCompile(`docs-cloud-f5-com\.\d+\.public\.ves\.io\.schema\.(.+)\.ves-swagger\.json`)
	matches := re.FindStringSubmatch(filename)
	if len(matches) < 2 {
		return ""
	}

	// Convert the schema path to resource name
	// e.g., "views.http_loadbalancer" -> "http_loadbalancer"
	// e.g., "namespace" -> "namespace"
	schemaPath := matches[1]

	// Handle nested schemas like "views.http_loadbalancer"
	parts := strings.Split(schemaPath, ".")
	resourcePart := parts[len(parts)-1]

	// Convert to snake_case
	return toSnakeCase(resourcePart)
}

func extractAPIPath(path string) string {
	// Extract the base API path (e.g., /config/namespaces)
	re := regexp.MustCompile(`^(/[^/]+/[^/]+)`)
	matches := re.FindStringSubmatch(path)
	if len(matches) > 1 {
		return matches[1]
	}
	return "/config/namespaces"
}

func toStructName(name string) string {
	// Convert snake_case to PascalCase
	parts := strings.Split(name, "_")
	for i, part := range parts {
		if len(part) > 0 {
			// Handle common acronyms
			upper := strings.ToUpper(part)
			if isAcronym(upper) {
				parts[i] = upper
			} else {
				parts[i] = strings.ToUpper(part[:1]) + part[1:]
			}
		}
	}
	return strings.Join(parts, "")
}

func toSnakeCase(s string) string {
	// Convert PascalCase or camelCase to snake_case
	var result []rune
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result = append(result, '_')
		}
		result = append(result, r)
	}
	return strings.ToLower(string(result))
}

func isAcronym(s string) bool {
	acronyms := map[string]bool{
		"API": true, "DNS": true, "HTTP": true, "HTTPS": true,
		"TCP": true, "UDP": true, "TLS": true, "SSL": true,
		"IP": true, "URL": true, "URI": true, "ID": true,
		"AWS": true, "GCP": true, "WAF": true, "ACL": true,
		"BGP": true, "VPC": true, "CDN": true, "LB": true,
		"K8S": true, "OIDC": true, "RBAC": true, "NAT": true,
		"CRL": true, "CA": true, "TGW": true, "VNET": true,
	}
	return acronyms[s]
}

func cleanDescription(desc string) string {
	// Clean up description for use in Go comments
	desc = strings.ReplaceAll(desc, "\"", "'")
	desc = strings.ReplaceAll(desc, "\n", " ")
	desc = strings.TrimSpace(desc)
	if len(desc) > 200 {
		desc = desc[:197] + "..."
	}
	if desc == "" {
		desc = "Manages an F5 Distributed Cloud resource."
	}
	return desc
}

func generateResource(resourcesDir string, res ResourceInfo) error {
	// Create resource directory
	resDir := filepath.Join(resourcesDir, res.PackageName)

	// Skip if directory already exists (don't overwrite manual customizations)
	if _, err := os.Stat(resDir); err == nil {
		return nil // Already exists, skip
	}

	if err := os.MkdirAll(resDir, 0755); err != nil {
		return err
	}

	// Create template data
	data := struct {
		ResourceInfo
		APIResource string
	}{
		ResourceInfo: res,
		APIResource:  toAPIResource(res.Name),
	}

	// Generate resource.go
	tmpl, err := template.New("resource").Parse(resourceTemplate)
	if err != nil {
		return err
	}

	filePath := filepath.Join(resDir, "resource.go")
	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	return tmpl.Execute(file, data)
}

func generateDataSource(datasourcesDir string, res ResourceInfo) error {
	// Create datasource directory
	dsDir := filepath.Join(datasourcesDir, res.PackageName)

	// Skip if directory already exists
	if _, err := os.Stat(dsDir); err == nil {
		return nil // Already exists, skip
	}

	if err := os.MkdirAll(dsDir, 0755); err != nil {
		return err
	}

	// Create template data
	data := struct {
		ResourceInfo
		APIResource string
	}{
		ResourceInfo: res,
		APIResource:  toAPIResource(res.Name),
	}

	// Generate datasource.go
	tmpl, err := template.New("datasource").Parse(datasourceTemplate)
	if err != nil {
		return err
	}

	filePath := filepath.Join(dsDir, "datasource.go")
	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	return tmpl.Execute(file, data)
}

func toAPIResource(name string) string {
	// Convert snake_case to API resource path (usually plural)
	// e.g., "http_loadbalancer" -> "http_loadbalancers"
	if strings.HasSuffix(name, "y") {
		return name[:len(name)-1] + "ies"
	}
	if strings.HasSuffix(name, "s") || strings.HasSuffix(name, "x") || strings.HasSuffix(name, "ch") {
		return name + "es"
	}
	return name + "s"
}

func generateProviderImports(projectRoot string, resources []ResourceInfo) error {
	// Generate a file with all imports and registrations
	importsPath := filepath.Join(projectRoot, "internal", "provider", "generated_resources.go")

	file, err := os.Create(importsPath)
	if err != nil {
		return err
	}
	defer file.Close()

	// Write header
	fmt.Fprintln(file, `// Copyright (c) Robin Mordasiewicz
// SPDX-License-Identifier: MPL-2.0

// Code generated by tools/generator. DO NOT EDIT.

package provider

// This file is generated by tools/generator/main.go
// Run 'go generate ./...' or 'go run tools/generator/main.go' to regenerate

// GeneratedResourcesList contains all resources generated from OpenAPI specs
var GeneratedResourcesList = []string{`)

	for _, res := range resources {
		if res.HasCreate && res.HasRead && res.HasDelete {
			fmt.Fprintf(file, "\t%q,\n", res.Name)
		}
	}
	fmt.Fprintln(file, "}")

	fmt.Fprintln(file, `
// GeneratedDataSourcesList contains all data sources generated from OpenAPI specs
var GeneratedDataSourcesList = []string{`)

	for _, res := range resources {
		if res.HasRead {
			fmt.Fprintf(file, "\t%q,\n", res.Name)
		}
	}
	fmt.Fprintln(file, "}")

	return nil
}

// Template for generating resource documentation
const resourceDocTemplate = `---
page_title: "{{.TypeName}} Resource - terraform-provider-f5distributedcloud"
subcategory: ""
description: |-
  {{.Description}}
---

# {{.TypeName}} (Resource)

{{.Description}}

## Example Usage

` + "```" + `hcl
resource "{{.TypeName}}" "example" {
  name        = "example-{{.Name}}"
  namespace   = "system"
  description = "Example {{.StructName}} resource"
}
` + "```" + `

## Argument Reference

- ` + "`name`" + ` - (Required) Name of the resource.
- ` + "`namespace`" + ` - (Required) Namespace where the resource will be created.
- ` + "`description`" + ` - (Optional) Description of the resource.
- ` + "`labels`" + ` - (Optional) Labels for the resource.
- ` + "`annotations`" + ` - (Optional) Annotations for the resource.

## Attribute Reference

- ` + "`id`" + ` - The unique identifier for this resource.

## Import

{{.StructName}} can be imported using the namespace and name:

` + "```" + `shell
terraform import {{.TypeName}}.example namespace/name
` + "```" + `
`

// Template for generating data source documentation
const datasourceDocTemplate = `---
page_title: "{{.TypeName}} Data Source - terraform-provider-f5distributedcloud"
subcategory: ""
description: |-
  {{.Description}}
---

# {{.TypeName}} (Data Source)

{{.Description}}

## Example Usage

` + "```" + `hcl
data "{{.TypeName}}" "example" {
  name      = "example-{{.Name}}"
  namespace = "system"
}
` + "```" + `

## Argument Reference

- ` + "`name`" + ` - (Required) Name of the resource.
- ` + "`namespace`" + ` - (Required) Namespace of the resource.

## Attribute Reference

- ` + "`id`" + ` - The unique identifier for this resource.
- ` + "`description`" + ` - Description of the resource.
`

// Template for generating resource example
const exampleTemplate = `# Example configuration for {{.TypeName}}

resource "{{.TypeName}}" "example" {
  name        = "example-{{.Name}}"
  namespace   = "system"
  description = "Example {{.StructName}} resource managed by Terraform"

  # Add additional configuration as needed
}
`

// Template for generating data source example
const datasourceExampleTemplate = `# Example configuration for {{.TypeName}} data source

data "{{.TypeName}}" "example" {
  name      = "existing-{{.Name}}"
  namespace = "system"
}

output "{{.Name}}_id" {
  value = data.{{.TypeName}}.example.id
}
`

func generateResourceDoc(docsDir string, res ResourceInfo) error {
	// Create docs/resources directory
	resourceDocsDir := filepath.Join(docsDir, "resources")
	if err := os.MkdirAll(resourceDocsDir, 0755); err != nil {
		return err
	}

	// Generate documentation file
	tmpl, err := template.New("resourceDoc").Parse(resourceDocTemplate)
	if err != nil {
		return err
	}

	docPath := filepath.Join(resourceDocsDir, res.Name+".md")
	file, err := os.Create(docPath)
	if err != nil {
		return err
	}
	defer file.Close()

	return tmpl.Execute(file, res)
}

func generateDataSourceDoc(docsDir string, res ResourceInfo) error {
	// Create docs/data-sources directory
	dsDocsDir := filepath.Join(docsDir, "data-sources")
	if err := os.MkdirAll(dsDocsDir, 0755); err != nil {
		return err
	}

	// Generate documentation file
	tmpl, err := template.New("datasourceDoc").Parse(datasourceDocTemplate)
	if err != nil {
		return err
	}

	docPath := filepath.Join(dsDocsDir, res.Name+".md")
	file, err := os.Create(docPath)
	if err != nil {
		return err
	}
	defer file.Close()

	return tmpl.Execute(file, res)
}

func generateResourceExample(examplesDir string, res ResourceInfo) error {
	// Create examples/resources directory
	resourceExamplesDir := filepath.Join(examplesDir, "resources", res.TypeName)
	if err := os.MkdirAll(resourceExamplesDir, 0755); err != nil {
		return err
	}

	// Generate example file
	tmpl, err := template.New("example").Parse(exampleTemplate)
	if err != nil {
		return err
	}

	examplePath := filepath.Join(resourceExamplesDir, "main.tf")
	file, err := os.Create(examplePath)
	if err != nil {
		return err
	}
	defer file.Close()

	return tmpl.Execute(file, res)
}

func generateDataSourceExample(examplesDir string, res ResourceInfo) error {
	// Create examples/data-sources directory
	dsExamplesDir := filepath.Join(examplesDir, "data-sources", res.TypeName)
	if err := os.MkdirAll(dsExamplesDir, 0755); err != nil {
		return err
	}

	// Generate example file
	tmpl, err := template.New("dsExample").Parse(datasourceExampleTemplate)
	if err != nil {
		return err
	}

	examplePath := filepath.Join(dsExamplesDir, "main.tf")
	file, err := os.Create(examplePath)
	if err != nil {
		return err
	}
	defer file.Close()

	return tmpl.Execute(file, res)
}

func generateAllDocs(projectRoot string, resources []ResourceInfo) error {
	docsDir := filepath.Join(projectRoot, "docs")
	examplesDir := filepath.Join(projectRoot, "examples")

	var resourceCount, datasourceCount int

	for _, res := range resources {
		// Generate resource docs and examples
		if res.HasCreate && res.HasRead && res.HasDelete {
			if err := generateResourceDoc(docsDir, res); err != nil {
				log.Printf("Warning: Could not generate doc for resource %s: %v", res.Name, err)
				continue
			}
			if err := generateResourceExample(examplesDir, res); err != nil {
				log.Printf("Warning: Could not generate example for resource %s: %v", res.Name, err)
				continue
			}
			resourceCount++
		}

		// Generate data source docs and examples
		if res.HasRead {
			if err := generateDataSourceDoc(docsDir, res); err != nil {
				log.Printf("Warning: Could not generate doc for data source %s: %v", res.Name, err)
				continue
			}
			if err := generateDataSourceExample(examplesDir, res); err != nil {
				log.Printf("Warning: Could not generate example for data source %s: %v", res.Name, err)
				continue
			}
			datasourceCount++
		}
	}

	log.Printf("Generated documentation: %d resources, %d data sources", resourceCount, datasourceCount)
	return nil
}
